//一.文件i/O模块的总结

//1.PCB(task_struct)(sched.h) struct files_struct *files
//2.---->  struct file{拥有各种信息}(fs.h) ---其中的一项--->fd _array[](fdtable.h)
//   struct file *fd_array[];
//   struct file __rcu * fd_array[NR_OPEN_DEFAULT];


//内核文件描述信息结构体组的下标就是fd  
//操作文件(打开,删除,写,关闭~~~~等),这些系统调用接口函数,返回的是一个整形数,返回了文件描述符(本质是文件描述表的下标)
//起到一个索引的作用,通过PCB的文件描述符找到该fd所指向的文件指针filp
//
//
//
//
//
//PCB每个进程都有,那么这个files_struct,每个进程都有了,当需要打开文件的时候,拿出来用
//struct file 中有很多关于文件的参数描写{f_count ,f_flag ,f_pos,,,,,,,}
//file_operations每一个file中都有,而这个结构体里面都是函数指针,指向了各种操作的函数
//
//进程通过open(),打开文件,实质上是获得一个文件描述符(不管这个文件存在不存在),便于进程通过文件描述符为连接文件进行
//其他操作,进程打开文件时候,会创建一个file对象,并把file对象存入进程打开文件表中(文件描述符数组)(按照最小未分配的规则),进而确定了
//所打开文件的文件描述符(这个时候其实fd并没有创建起来,open完成了功能之后,就会获得一个fd)
//那么这时候open通过内核调用的函数就会返回给外部一个整形变量
//
//
//简单归纳 :fd只是一个整数，在open时产生。起到一个索引的作用，进程通过PCB中的文件描述符表找到该fd所指向的文件指针filp。

//linux下遵循一切皆文件这个思想
//在文件描述符数组的前三个已经占用了,就是stdin,stdout,stderr,0,1,2
//所以自己打开的文件,文件描述符至少是从三开始的
//
//close (int  fd)  关闭文件操作符,使它不在指向任何一个文件和不能在新的文件中使用
//
//
//C中是将接口封装了一层使用了文件指针文件指针这个结构 (usr/include/stdio.h (头文件中只是放了各种各样的声明)  )
//
// struct _IO_FILE;
// 
// __BEGIN_NAMESPACE_STD
///* The opaque type of streams.  This is the definition used elsewhere.  */
//typedef struct _IO_FILE FILE;
//
//在这个文件中定义了文件流指针的结构
//
// int  fileno 
// 对文件流 返回系统文件描述符
// /* Return the system file descriptor for STREAM.  */
//
// extern int fileno (FILE *__stream) __THROW __wur;
//
// 经过验证fileno 就是封装起来的文件描述符
//
// 那么如何完成的重定向我的理解就是偷梁换柱了一把,fileno是个傻子,只知道被柱子顶着,但是柱子换了,方向也变了(fd被更换),都不知道,
// 那么结果就变了,
//
// 重定向的函数 
//
// int  dup2( int oldfd,int newfd );
//
// dup2,dup 用来复制文件描述符
//
// oldfd 就是旧文件描述符
//
// newfd 就是新文件描述符
//
// 将旧文件描述符复制给新文件描述符
// 可以选择性的关闭旧的文件描述符,避免资源浪费
//
// int dup(int oldfd);
//
// 这个复制成功返回的是最小的尚未被使用的文件描述符,如果有错误那么返回-1,返回的新文件的描述符和旧文件描述符指向了同一个文件
//
//
//-------------------------------------------------------------------------------------------------------------------------
//
//
//二. 文件操作系统
//
//ls -l 包括了文件元数据
//
//模式 硬链接数 文件所有者 组 大小 最后修改时间 文件名
//
//
//stat 命令可以看到更多的信息

//EXT2  Linux second extend file system ,(Ext2fs)
//
// 在根目录下的dev下存放的是外设文件,是黄色的
// 这些设备也被当做文件来对待
// 硬盘有两种传输接口一个是IDE
// 一个是SATA接口
// 整块磁盘的第一个扇区最重要,因为记录了两个重要信息
//
// 1. 主引导分区(Master Boot Record ,MBR)(可安装引导加载程序的地方)(446字节)
// 2.分区表(partition table )(记录磁盘分区状态的)(64个字节)
// 开机的时候,系统会主动的读取这个区块的内容,这样系统才知道你的程序放在那里该如何进行开机
// 开机刷磁头,就要读取第一个扇区的内容
//-------------------------------------------------------------------------------------------------------
// (基本输入输出系统)
// BIOS它是一组固化到计算机内主板上一个ROM芯片上的程序
// 它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序
// 它可从CMOS中读写系统设置的具体信息
// CMOS
// 在计算机领域，CMOS常指保存计算机基本启动信息（如日期、时间、启动设置等）的芯片。
// 有时人们会把CMOS和BIOS混称
// 其实CMOS是主板上的一块可读写的并行或串行FLASH芯片
// 是用来保存BIOS的硬件配置和用户对某些参数的设定。
//(CMOS)是一个存储器,记录各项硬件参数且嵌入在主板当中
//
//开机流程----------------------------------------------------------------------------------------------
//1.BIOS :   开机主动执行的韧体,会认识第一个开始的设备
//2.MBR :    第一个可开机设备的第一个扇区的主引导分区块,内包含引导加载程序
//3.引导加载程序(Boot loader) : 一个可读取内核文件来执行的软件(目的是加载内核文件,并执行内核文件)
// 引导加载程序是操作系统在安装的时候提供的,所以他能够识别硬盘文件的系统格式,因此就可以
// 读取内核文件,引导完了之后,那么就是操作系统的任务了.
//
//Boot loader 的主要任务  提供菜单:用户可以选择不同的开机选项(可能这个程序的菜单有直接加载window系统,也可能是第二分区的启动扇区)
//,这也是多重引导的重要功能
//
//
//载入内核文件: 直接指向可开机的程序区段来开始操作系统
//
//转交其他的 loader  其他分区的引导扇区也有loader(那么其他扇区的loader只认其自己的分区的可开机内核文件)
//
//4.内核文件:开始操作系统的功能
//----------------------------------------------------------------------------------------------------
//
//为什么需要格式化? 因为每种操作系统所设置的文件属性/权限并不相同,为了
//存放这些文件所需要的数据,因此就需要将分区进行格式化,以成为操作系统能够利用
//的文件系统格式
//
//每种操作系统使用的文件系统不相同  Linux (Ext2),window(FAT)
//
//传统的格式化就是一个分区只能被格式化成为一个文件系统,但是现在新技术
//可以将一个分区化为多个文件系统,也能够将多个分区合并为一个文件系统
//
//所以现在称一个可被挂载的数据为一个文件系统而不是一个分区
//
//
//文件的数据 :   文件的内容,还有文件的很多属性,Linux分为文件权限,与文件的属性,文件系统
//会将这两部分数据存放在不同的块,权限与属性放置到 inode ,实际数据放置到data block中,
//super block 记录文件系统的整体信息
//
//inode(文件的属性以及权限)  block(数据) 都是有编号的
//inode 里面就有block号码(文件存放块)
//在硬盘就和内存是一致的,可能是连续存放的文件,也可能不是连续存放的
//block存放的一个文件,可能是零零散散的,这样就构成了磁盘的碎片化(block的分配太过离散)
//当然就有磁盘碎片化管理了
//
//inode和block都有编号! 再次做一个重复
//
//某一个文件存在inode5里面,inode5里面记录了其各个block各个的号码,此时操作系统会排列
//阅读顺序,就可以将block的号码读出来,
//这种就叫索引式文件系统,
//
//FAT在U盘(闪存)上一般为FAT格式,他没有inode存在,所以他的block都记录在上一个block中,类似于
//链表的方式吧,比如说一个文件的block2,他的上一个为block7,那么他就记录在7这个里面
//,但是他没办法知道一口气知道一个文件的所有block,所以他得一个一个读出来,这样如果block太分散,磁头
//转一圈也读不到数据,得转好多圈
//
//磁盘碎片化多在FAT中,因为Linux是索引式文件系统,但是文件系统用的久了,删除编辑,新增也难免会造成离散block
//
//
//block是存放数据的所以大小是固定的  4096个字节
//(data block)数据块
//data block  有不同的大小,1kb 2kb 4kb
//不同的大小能承载的单一文件大小和最大文件系统容量都不相同
//stat  查看文件的具体信息
//super block (超级块)记录整个文件相关的信息
//dumpe2fs  调出查看 
//一个文件系统仅有一个super block 可能其他的文件分区也有但是只是一个备份
//Block group  块的分组  
//block  bitmap  当中可以知道哪些block是空的,格式化就是把表中的标志置为未使用
//inode bitmap 则是记录 使用与未使用的inode的号码    
//
//范例  df  调出目前挂载的设备
//df -th  查看文件系统的类型
//cenos7 不是ext2 的文件类型,而是xfs 的文件类型
//xfs_growfs  使用这个查看
//
//tmpfs基于内存的文件系统 
//
//devtmpfs的功用是在linux核心启动早期建立一个初步的 /dev,令一般启动程序不用等待udev  缩短开机时间
//
//centos7.0开始默认文件系统是xfs，centos6是ext4，centos5是ext3
//ext3和ext4的最大区别在于，ext3在fsck时需要耗费大量时间（文件越多，时间越长），而ext4在fsck时用的时间会少非常多
//ext4是第四代扩展文件系统（英语：Fourth EXtended filesystem，缩写为ext4）是linux系统下的日志文件系统，是ext3文件系统的后继版本
//
//
//
//xfs是一种非常优秀的日志文件系统，它是SGI公司设计的。xfs被称为业界最先进的、最具可升级性的文件系统技术
//xfs是一个64位文件系统，最大支持8EB减1字节的单个文件系统，实际部署时取决于宿主操作系统的最大块限制。对于一个32位Linux系统，文件和文件系统的大小会被限制在16TB
//xfs在很多方面确实做的比ext4好，ext4受限制于磁盘结构和兼容问题，可扩展性和scalability确实不如xfs，
//另外xfs经过很多年发展，各种锁的细化做的也比较好
//
//xfs 是一种先进的日志文件系统
//SGI公司设计的。xfs被称为业界最先进的、最具可升级性的文件系统技术
//xfs是一个64位文件系统，最大支持8EB减1字节的单个文件系统，实际部署时取决于宿主操作系统的最大块限制。对于一个32位Linux系统，文件和文件系统的大小会被限制在16TB
//xfs在很多方面确实做的比ext4好，ext4受限制于磁盘结构和兼容问题，可扩展性和scalability确实不如xfs，另外xfs经过很多年发展，各种锁的细化做的也比较好
//
//-------------------------------------------------------------------
//
//与目录树的关系  
//
//查看inode节点号 ls -li
//如果有个文件过多那么会给多个block来继续记录相关的数据
//
//
//读取 /etc/passed 文件内容 
//第一步: ./的 inode号码    通过挂载点信息找到根目录的挂载目录(分区,是一个链接文件)进而找到根目录的inode号码且inode具有的权限让我们可以读取该block的内容
//
//  /的block  得到/的block号码 block存储的是数据, 找到内容里面有etc/目录的inode号码
//
//  etc的inode   读取etc的inode的号码  得知用户具有的权限,是否可以读写etc的内容
//  读取etc目录中block内容
//  找到关于passwd的inode号码
//  判断是否具有读写权限,
//  读取passwd的block内容 
//  最后将block内容读写出来
//
//
//--------------------------------------------------------------------------
//
//  软硬链接
//  ln   xxx(已经存在的一个文件)   xxx(一个未存在的文件)
//硬链接共用一个ionde节点
//只是在某个目录下新建一条文件名链接到某inode 号码关联记录而已
//新增一个连接数  连接字段 显示有多少文件名连接到这个inode节点当中
//硬链接文件的大小就是连接文件的大小
//
//
//ln  [-sf]  源文件 目标文件 
//
//symbolic link  (符号链接)
//也是快捷方式
//
//创建的软连接 指向不同的inode节点,也就是说他们是两个不同的文件
//软连接之后会写上目标文件的文件名 ,但是他的大小只是文件名称的大小,就是有多少个英文
//1个英文1个bytes  
//软连接连接的是一个连接文件,所以类似于桌面的快捷方式, 
//
//
//黄色的表示设备文件
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
