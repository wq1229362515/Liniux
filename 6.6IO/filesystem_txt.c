//一.文件i/O模块的总结

//1.PCB(task_struct)(sched.h) struct files_struct *files
//2.---->  struct file{拥有各种信息}(fs.h) ---其中的一项--->fd _array[](fdtable.h)
//   struct file *fd_array[];
//   struct file __rcu * fd_array[NR_OPEN_DEFAULT];


//内核文件描述信息结构体组的下标就是fd  
//操作文件(打开,删除,写,关闭~~~~等),这些系统调用接口函数,返回的是一个整形数,返回了文件描述符(本质是文件描述表的下标)
//起到一个索引的作用,通过PCB的文件描述符找到该fd所指向的文件指针filp
//
//
//
//
//
//PCB每个进程都有,那么这个files_struct,每个进程都有了,当需要打开文件的时候,拿出来用
//struct file 中有很多关于文件的参数描写{f_count ,f_flag ,f_pos,,,,,,,}
//file_operations每一个file中都有,而这个结构体里面都是函数指针,指向了各种操作的函数
//
//进程通过open(),打开文件,实质上是获得一个文件描述符(不管这个文件存在不存在),便于进程通过文件描述符为连接文件进行
//其他操作,进程打开文件时候,会创建一个file对象,并把file对象存入进程打开文件表中(文件描述符数组)(按照最小未分配的规则),进而确定了
//所打开文件的文件描述符(这个时候其实fd并没有创建起来,open完成了功能之后,就会获得一个fd)
//那么这时候open通过内核调用的函数就会返回给外部一个整形变量
//
//
//简单归纳 :fd只是一个整数，在open时产生。起到一个索引的作用，进程通过PCB中的文件描述符表找到该fd所指向的文件指针filp。

//linux下遵循一切皆文件这个思想
//在文件描述符数组的前三个已经占用了,就是stdin,stdout,stderr,0,1,2
//所以自己打开的文件,文件描述符至少是从三开始的
//
//close (int  fd)  关闭文件操作符,使它不在指向任何一个文件和不能在新的文件中使用
//
//
//C中是将接口封装了一层使用了文件指针文件指针这个结构 (usr/include/stdio.h (头文件中只是放了各种各样的声明)  )
//
// struct _IO_FILE;
// 
// __BEGIN_NAMESPACE_STD
///* The opaque type of streams.  This is the definition used elsewhere.  */
//typedef struct _IO_FILE FILE;
//
//在这个文件中定义了文件流指针的结构
//
// int  fileno 
// 对文件流 返回系统文件描述符
// /* Return the system file descriptor for STREAM.  */
//
// extern int fileno (FILE *__stream) __THROW __wur;
//
// 经过验证fileno 就是封装起来的文件描述符
//
// 那么如何完成的重定向我的理解就是偷梁换柱了一把,fileno是个傻子,只知道被柱子顶着,但是柱子换了,方向也变了(fd被更换),都不知道,
// 那么结果就变了,
//
// 重定向的函数 
//
// int  dup2( int oldfd,int newfd );
//
// dup2,dup 用来复制文件描述符
//
// oldfd 就是旧文件描述符
//
// newfd 就是新文件描述符
//
// 将旧文件描述符复制给新文件描述符
// 可以选择性的关闭旧的文件描述符,避免资源浪费
//
// int dup(int oldfd);
//
// 这个复制成功返回的是最小的尚未被使用的文件描述符,如果有错误那么返回-1,返回的新文件的描述符和旧文件描述符指向了同一个文件
//
//
//-------------------------------------------------------------------------------------------------------------------------
//
//
//二. 文件操作系统
//
//ls -l 包括了文件元数据
//
//模式 硬链接数 文件所有者 组 大小 最后修改时间 文件名
//
//
//stat 命令可以看到更多的信息

//EXT2  Linux second extend file system ,(Ext2fs)
//
// 在根目录下的dev下存放的是外设文件,是黄色的
// 这些设备也被当做文件来对待
// 硬盘有两种传输接口一个是IDE
// 一个是SATA接口
// 整块磁盘的第一个扇区最重要,因为记录了两个重要信息
//
// 1. 主引导分区(Master Boot Record ,MBR)(可安装引导加载程序的地方)(446字节)
// 2.分区表(partition table )(记录磁盘分区状态的)(64个字节)
// 开机的时候,系统会主动的读取这个区块的内容,这样系统才知道你的程序放在那里该如何进行开机
// 开机刷磁头,就要读取第一个扇区的内容
//-------------------------------------------------------------------------------------------------------
// (基本输入输出系统)
// BIOS它是一组固化到计算机内主板上一个ROM芯片上的程序
// 它保存着计算机最重要的基本输入输出的程序、开机后自检程序和系统自启动程序
// 它可从CMOS中读写系统设置的具体信息
// CMOS
// 在计算机领域，CMOS常指保存计算机基本启动信息（如日期、时间、启动设置等）的芯片。
// 有时人们会把CMOS和BIOS混称
// 其实CMOS是主板上的一块可读写的并行或串行FLASH芯片
// 是用来保存BIOS的硬件配置和用户对某些参数的设定。
//(CMOS)是一个存储器,记录各项硬件参数且嵌入在主板当中
//
//开机流程----------------------------------------------------------------------------------------------
//1.BIOS :   开机主动执行的韧体,会认识第一个开始的设备
//2.MBR :    第一个可开机设备的第一个扇区的主引导分区块,内包含引导加载程序
//3.引导加载程序(Boot loader) : 一个可读取内核文件来执行的软件(目的是加载内核文件,并执行内核文件)
// 引导加载程序是操作系统在安装的时候提供的,所以他能够识别硬盘文件的系统格式,因此就可以
// 读取内核文件,引导完了之后,那么就是操作系统的任务了.
//
//Boot loader 的主要任务  提供菜单:用户可以选择不同的开机选项(可能这个程序的菜单有直接加载window系统,也可能是第二分区的启动扇区)
//,这也是多重引导的重要功能
//
//
//载入内核文件: 直接指向可开机的程序区段来开始操作系统
//
//转交其他的 loader  其他分区的引导扇区也有loader(那么其他扇区的loader只认其自己的分区的可开机内核文件)
//
//4.内核文件:开始操作系统的功能
//----------------------------------------------------------------------------------------------------
//
//为什么需要格式化? 因为每种操作系统所设置的文件属性/权限并不相同,为了
//存放这些文件所需要的数据,因此就需要将分区进行格式化,以成为操作系统能够利用
//的文件系统格式
//
//每种操作系统使用的文件系统不相同  Linux (Ext2),window(FAT)
//
//传统的格式化就是一个分区只能被格式化成为一个文件系统,但是现在新技术
//可以将一个分区化为多个文件系统,也能够将多个分区合并为一个文件系统
//
//所以现在称一个可被挂载的数据为一个文件系统而不是一个分区
//
//
//文件的数据 :   文件的内容,还有文件的很多属性,Linux分为文件权限,与文件的属性,文件系统
//会将这两部分数据存放在不同的块,权限与属性放置到 inode ,实际数据放置到data block中,
//super block 记录文件系统的整体信息
//
//inode(文件的属性以及权限)  block(数据) 都是有编号的
//inode 里面就有block号码(文件存放块)
//在硬盘就和内存是一致的,可能是连续存放的文件,也可能不是连续存放的
//block存放的一个文件,可能是零零散散的,这样就构成了磁盘的碎片化(block的分配太过离散)
//当然就有磁盘碎片化管理了
//
//inode和block都有编号! 再次做一个重复
//
//某一个文件存在inode5里面,inode5里面记录了其各个block各个的号码,此时操作系统会排列
//阅读顺序,就可以将block的号码读出来,
//这种就叫索引式文件系统,
//
//FAT在U盘(闪存)上一般为FAT格式,他没有inode存在,所以他的block都记录在上一个block中,类似于
//链表的方式吧,比如说一个文件的block2,他的上一个为block7,那么他就记录在7这个里面
//,但是他没办法知道一口气知道一个文件的所有block,所以他得一个一个读出来,这样如果block太分散,磁头
//转一圈也读不到数据,得转好多圈
//
//磁盘碎片化多在FAT中,因为Linux是索引式文件系统,但是文件系统用的久了,删除编辑,新增也难免会造成离散block
//
//
//block是存放数据的所以大小是固定的  4096个字节
//(data block)数据块
//data block  有不同的大小,1kb 2kb 4kb
//不同的大小能承载的单一文件大小和最大文件系统容量都不相同
//stat  查看文件的具体信息
//super block (超级块)记录整个文件相关的信息
//dumpe2fs  调出查看 
//一个文件系统仅有一个super block 可能其他的文件分区也有但是只是一个备份
//Block group  块的分组  
//block  bitmap  当中可以知道哪些block是空的,格式化就是把表中的标志置为未使用
//inode bitmap 则是记录 使用与未使用的inode的号码    
//
//范例  df  调出目前挂载的设备
//df -th  查看文件系统的类型
//cenos7 不是ext2 的文件类型,而是xfs 的文件类型
//xfs_growfs  使用这个查看
//
//tmpfs基于内存的文件系统 
//
//devtmpfs的功用是在linux核心启动早期建立一个初步的 /dev,令一般启动程序不用等待udev  缩短开机时间
//
//centos7.0开始默认文件系统是xfs，centos6是ext4，centos5是ext3
//ext3和ext4的最大区别在于，ext3在fsck时需要耗费大量时间（文件越多，时间越长），而ext4在fsck时用的时间会少非常多
//ext4是第四代扩展文件系统（英语：Fourth EXtended filesystem，缩写为ext4）是linux系统下的日志文件系统，是ext3文件系统的后继版本
//
//
//
//xfs是一种非常优秀的日志文件系统，它是SGI公司设计的。xfs被称为业界最先进的、最具可升级性的文件系统技术
//xfs是一个64位文件系统，最大支持8EB减1字节的单个文件系统，实际部署时取决于宿主操作系统的最大块限制。对于一个32位Linux系统，文件和文件系统的大小会被限制在16TB
//xfs在很多方面确实做的比ext4好，ext4受限制于磁盘结构和兼容问题，可扩展性和scalability确实不如xfs，
//另外xfs经过很多年发展，各种锁的细化做的也比较好
//
//xfs 是一种先进的日志文件系统
//SGI公司设计的。xfs被称为业界最先进的、最具可升级性的文件系统技术
//xfs是一个64位文件系统，最大支持8EB减1字节的单个文件系统，实际部署时取决于宿主操作系统的最大块限制。对于一个32位Linux系统，文件和文件系统的大小会被限制在16TB
//xfs在很多方面确实做的比ext4好，ext4受限制于磁盘结构和兼容问题，可扩展性和scalability确实不如xfs，另外xfs经过很多年发展，各种锁的细化做的也比较好
//
//-------------------------------------------------------------------
//
//与目录树的关系  
//
//查看inode节点号 ls -li
//如果有个文件过多那么会给多个block来继续记录相关的数据
//
//
//读取 /etc/passed 文件内容 
//第一步: ./的 inode号码    通过挂载点信息找到根目录的挂载目录(分区,是一个链接文件)进而找到根目录的inode号码且inode具有的权限让我们可以读取该block的内容
//
//  /的block  得到/的block号码 block存储的是数据, 找到内容里面有etc/目录的inode号码
//
//  etc的inode   读取etc的inode的号码  得知用户具有的权限,是否可以读写etc的内容
//  读取etc目录中block内容
//  找到关于passwd的inode号码
//  判断是否具有读写权限,
//  读取passwd的block内容 
//  最后将block内容读写出来
//
//
//--------------------------------------------------------------------------
//
//  软硬链接
//  ln   xxx(已经存在的一个文件)   xxx(一个未存在的文件)
//硬链接共用一个ionde节点
//只是在某个目录下新建一条文件名链接到某inode 号码关联记录而已
//新增一个连接数  连接字段 显示有多少文件名连接到这个inode节点当中
//硬链接文件的大小就是连接文件的大小(文件别名,与源文件操作同一个inode节点)
//
//
//ln  [-sf]  源文件 目标文件 
//
//symbolic link  (符号链接)
//也是快捷方式
//
//创建的软连接 指向不同的inode节点,也就是说他们是两个不同的文件
//软连接之后会写上目标文件的文件名 ,但是他的大小只是文件名称的大小,就是有多少个英文
//1个英文1个bytes  
//软连接连接的是一个连接文件,所以类似于桌面的快捷方式, 
//(存储的是文件的 目录项,也就是文件的路径)
//
//黄色的表示设备文件
//
//-----------------------------------------
//缓冲区
//
//
//描述了一段内存 (一段区域)
//
//FILE *fp{
//
//
//
//}    
//stdio.h  描述了读写缓冲区 库里面的缓冲区
//(用户态缓冲区)
//
//内核态和用户态的区分
//
//用户态 :程序运行的这段代码是程序员自己写的,或者运行的是库函数,那么是用户态运行
//内核态: 程序运行的是系统调用接口,程序运行在内核态
//
//_exit 系统调用,根本没有缓冲区  
//
//--------------------------------------------------------------
//
//操作系统为用户提供的几种进程间通信方式的学习
//进程间通信  因为进程的独立性,都操作的是自己虚拟空间中的虚拟地址,没法访问别进程的空间,无法直接通信
//于是操作系统要给用户提供进程通信
//
//
//标准
//system V  : 管道,共享内存,消息队列,信息量 
//
//posix (跨平台):重新编译一遍就可以运行    信号量 
//
//管道本质:内核中的一块缓冲区  
//实现原理:多个进程通过访问相同的缓冲区实现通信
//使用的是系统调用io接口
//匿名管道 :只具有亲缘关系的进程通信
//一个进程创建匿名管道,操作系统在内核中重建一块缓冲区,返回两个文件描述符作为管道的操作句柄(一个用于读,一个用于写,方向选择权交给
//用户),这个缓冲区在内核中没有标识,意味着别人找不到他,我们这个进程能找到他因为返回了两个文件描述符,所以能找到
//
// man 2 pipe 
// 接口 int pipe(int pipefd[2]);
// 就有两个int型元素的数组
// 创建一个管道 ,通过pipefd获取系统返回的管道操作句柄
// pipefd[0]  从管道读取数据
// pipefd[1]  从管道写入数据
// 半双工通信
// 返回值 0成功  -1失败 
//
// 管道的特性:
//           1.若管道中没有数据,read会阻塞,直到数据写入
//           2.若管道数据满了,write会阻塞,直到数据读取
//           3.管道的所有读端关闭,write会异常
//           4.写端关闭,则read会返回0(所有写端关闭)   close(pipefd(1)); 父进程关闭了,子进程也要关闭 
//           (关闭所有写端,不要忘了自己)
//           若所有写端关闭,则read不再阻塞,读完数据后返回
//
//
// 管道符  通过匿名管道来实现
// ls |grep make
//
//
// ctrl +d 档次的输入结束
//
// 默认从标准输入读取数据 grep对读取到的数据进行匹配
// ls结果写到标准输出的
// 匿名管道的简单实现 :创建两个进程,一个运行ls ,一个运行grep make  dup2(pipefd[0],0);
// ls标准输出重定向 ,写入到管道写入段 dup2(pipefd[1],1)
//
//  minishell 
//  等待输入
//  等待| 切隔命令
//  命令解析流程不变
//  创建两个子进程 
//  程序替换
//  execvp(ls)
//  pipe
//  execvp(grep make)
//           缓冲区大小就是64k
//
//  命名管道 :有标识的,在内核中这块缓冲区是有标识的所有进程都可以通过这个标识找到这块缓冲区实现通信
//  可以用于同一主机的任意通信
//  mkfifo test.fifo 
//  这个文件就是命名管道的标识.所有进程都可以通过打开文件访问到内核中的缓冲区
//  只是一个名字这个文件,本质还是内核的缓冲区
//
//  char *fifo = "./xxxx";
//  umask(0);
//  int ret = mkfilfo(fifo,0664);
//  文件已存在
//  if(errno != EEXIST){
//      perror("");
//  } 
//
// 命名管道文件的打开特性:
// 若文件没有被已读的方式打开,以 O_WRONLY打开时会阻塞
// 若文件当前没有已被写的方式打开,以O_EDONLY打开会阻塞
//
// 管道的生命周期随进程(所有管道的操作句柄被关闭)
// 管道自带同步(操作的时序的合理性)与互斥(保证操作在同一时间的唯一性)
// (管道的读写大小不超过pipe_buf 4096 时,是安全的)
// 管道提供字节流服务  (传输特别灵活,但是粘包问题, 数据没有明显间隔)
//  一次性接受一点点,等一段时间接收,
//
//
//
//
//
//
//
//
//
//
