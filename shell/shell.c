/*
 * 交互式
 * 脚本下
 * #! bin/bash
 * echo "hello world"
 *
 * 1.运行的时候增加权限运行
 * 2.直接 bash test.sh
 *
 * shell 是可以提高工作效率的 
 *
 * 文本类文件，非编译型的文件
 * ./运行的是二进制文件  交互式程序先fork 在 exec 程序
 *
 * 创建子进程之后并不是直接执行shell脚本的，而是执行解释器 解释器是bash，再exec 
 * 
 * bash test.h
 * bash可以当做一个命令 这时候exec替换bash 再将test.h作为参数传进
 *
 * 原则上shell脚本的内容按行读取
 * 每一行都可以被当做一行命令
 * 他们的执行都必须遵守shell的运行原理
 *
 * shell脚本当中由交互式命令由bash亲自去执行的叫内建命令
 * 
 * . test.sh
 * .命令执行shell脚本可以由我们的交互式bash亲自执行，不需要创建子bash
 * 
 * source 命令和我们的.的作用是一样的
 * MYENV=100
 * 要变成环境变量必须要经历 export 所以上面的不是环境变量叫本地变量
 * export MYENV  
 *
 * 运行shell的第一步是fork,环境变量可以被子进程继承,本地变量只在本bash里面有效
 * 环境变量也是数据,
 *
 * 1.环境的全局特性表现在他可以被子孙进程继承下去
 * 2.环境变量在程序替换时候默认不会被替换掉
 * shell 变量如果从来没有被使用过,那么默认就是一个空串
 * shell 脚本中把所有的类型当做字符串来使用,所以没有类型之分,弱类型
 * 定义变量的时候要不用$ ,取变量的时候要用$ 
 *
 * 统配的方式
 * i=0;while [ $i -le 100  ];do touch file$i; let i++; done
 * 批量化的产生100 个文件
 *
 * 通配符* 匹配0个或者多个任意字符
 * ls file*
 *  ?  任意匹配一个字符
 *  [xxx] 
 *  file[1-9]
 *  ls file [1234567]
 *  ls file [^1-9]
 *  ls file?[2345]
 *  ls file[2345]*
 *  ls file[2345]?*
 *
 *  ret=$(date +%Y:%m:%d)
 *  echo "time is : $ret"
 *  命令代换 
 *  ''''''  单引号 
 *  ````   导引号
 *
 *  ``
 *  $()
 *
 *  eval 作用
 *
 *
 *   (( c= a+b  ))
 *   双圆括号括起来就相当于C语言
 *   (( c = a/b ))
 *
 *  shell 脚本中单引号和双引号都是将字符串扩起来的
 *  双引号会对相关的字体做出特殊的处理
 *  
 *  
 * shell 条件测试命令
 * test 
 * [ 
 * 
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * 
 *
